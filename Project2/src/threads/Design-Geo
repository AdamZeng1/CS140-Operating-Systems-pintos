დიზაინ დოკუმენტი
+-----------------+
|
	CS 140
|
| პროექტი 2       |
| დიზაინ დოკუმენტი |
+-----------------+
---- ჯგუფი ----
ლუკა მაჭარაძე <lmach14@freeuni.edu.ge>
გივი ბერიძე <gberi14@freeuni.edu.ge>
გიორგი გულიაშვილი<gguli13@freeuni.edu.ge>
თორნიკე ჟიჟიაშვილი<tzhiz14@freeuni.edu.ge>
---- წინასიტყვაობა ----
>> დაწერეთ თუ გამოიყენოთ გარე წყაროები გარდა პინტოსისა
არაფერი.


TIMER BUSY WAIT გაუმჯობესდა
===================

---- მონაცემთა სტრუქტურები ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.
 	/* სორტირებული სია  sleeping_thread */
	static struct list sleeping_threads_list;

	/* სრედს დაემატა გაღვიძების დამატებითი ინფორმაცია and list_elem სიისთვის, MAGIC გადავსების გასაგებად*/
	struct sleeping_thread{
	    struct list_elem elem;
	    struct thread *thread;
	    int64_t wake_up_time;
	    int MAGIC;
	};

---- ალგორითმები ----
>> A2:	 Briefly describe what happens in a call to timer_sleep(),
>> including the effects of the timer interrupt handler.

	timer_init იძახება ყველაფრის დაწყებამდე, ის ქმნის მძინარე სრედების სიას.
	timer_sleep აწყობს მძინარე სრდებს და სვამს მათ სიაში.
wake_up_threads მძინარე სრედებს ყრის სიიდან თუ  wake_up_time < now.
>> A3: What steps are taken to minimize the amount of time spent in
>> the timer interrupt handler?

---- სინქრონიზაცია ----
>> A4: How are race conditions avoided when multiple threads call
>> timer_sleep() simultaneously?

	timer_interrupt სრედი შეუძლებელია დაიბლოკოს ამიტომ ჩვენ ვიყენებთ ინტერაფთების გათიშვას რათა გავთიშოთ ინტერაფთები
	ატომური წაკითხვა/ჩაწერა ლისტიდან და ლისტში
>> A5: How are race conditions avoided when a timer interrupt occurs
>> during a call to timer_sleep()?
---- რაციონალურობა ----
>> A6: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

	სია საუკეთესო გზა არაა ელემენტების სორტირებულად შესანახად. Min Priority Queue იქნებოდა უკეთესი მაგრამ ის ალბათ წაიღებდა უფრო მეტ დროს და ექნებოდა უფრო მეტი ბაგები.


პრიორიტეტებით გაშვება
===================

---- მონაცემთა სტრუქტურები ----

>> B1: 	/* მძინარე სრედების სორტირებული სია */
	#define PRI_SIZE (PRI_MAX - PRI_MIN + 1)
	#define PRI_AD (-PRI_MIN)
	/* 64 განსხვავებული რიგი ყველა პრიორეტისთვის */
	static struct list ready_list[PRI_SIZE];
>> B2:  პრიორიტეტული სქედულერისთვის გამოყენებული გვაქვს სია : static struct list ready_list[PRI_SIZE] და #define PRI_SIZE (PRI_MAX - PRI_MIN + 1)
	#define PRI_AD (-PRI_MIN)

---- ალგორითმები ----
>> B3: /*სანამ ready_list იყო ერთი რიგი, სიმარტივისთვის ყველა სრედს ქონდა თავისი საკუთარი რიგი .*/ ჩასასწორებელია
ამ იმპლემენტაციაში  Round robing არის უფრო მარტივი  pop_front/push_back გზით.
>> B4:
>> B5: 

---- სინქრონიზაცია ----
>> B6: intr_disable გამოყენებულია ატომურობის ჩაწერა/წაკითხვისთვის  64 ready_list queues სიაში და სიიდან.

---- რაციონალურობა ----
>> B7: ყუთი კარგია ყველა პრიორიტეტის შენახვისთვის სწრაფად პოვნისთვის, უფრო კარგი მაგრამ რთUლი გზა იქნებოდა თუ ყველა პრიორიტეტს თავისი საკუთარი ლოქი ექნებოდა, ან კიდევ უკეთესი, რიგები არ იბლოკებოდნენ.


პრიორიტეტული დონაცია
===================

---- მონაცემთა სტრუქტურები ----

struct thread
{
    ...

    struct lock *waiting_lock;
    int priority;                       /* MAX(old_priority, donations) */
    struct list_elem allelem;           /* List element for all threads list. */
    int old_priority; /* latest priority setted by set_priority */


    /* Shared between thread.c and synch.c. */
    struct list_elem elem;              /* List element. */

    /* locks currently acquired by the thread */
    struct list acquired_locks_list;
    
    ...
};

---- ალგორითმები ----
ყველა სრედი ინახავს lock-ის  მიმთითებელს რომელსაც ელოდება.
ყველა სრედი ინახავს ჰოლდერს.
ყველა ლოქი ინახავს სრედებს რომელიც მას ელოდება.
ყველა სრედი ინახავს ლოქებს რომლებიც დალოქა.

როცა სრედი იწყებს ლოდინს(დონაციის ფაზა) ან რჩება ლოდინს .
როცა სრედს უნდა მიიღOს მაქსიმალური პრიორიტეტი , ის გადაუყვება ყველა სრედს რომელიც მას ელოდება ან ის ელოდება, ირჩევს მაქსიმალურ პრიორიტეტს და ისეტავს თავისთვის.


---- სინქრონიზაცია ----
არ იყო სინქრონიზაციის საჭიროება რადგან ყველა სრედი ცვლის მხოლოდ შიდა სტრუქტურას.

---- რაციონალურობა ----
ხანდახან ჯაჭვი შეიძლება იყოს ძალიან გრძელი. გრაფი არ არის ზოგადი, ყველა წვეროს აქვს მხოლოდ ერთი გამავალი წვერო. განსხვავებული მონაცემთა სტრუქტურებით ეს შესაძლოა ყოფილიყო უფრო სწრაფი O(N).



გაუმჯობესებული პრიორიტეტული გაშვება
===================

----მონაცემთა სტრუქტურები ----
>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

	static unsigned thread_ticks;   /* # of timer ticks since last yield. */
	static fixedPoint load_average = 0;
	struct thread
	{
	    ....

	    /* locks currently acquired by the thread */
	    struct list acquired_locks_list;
	    fixedPoint recent_cpu;

	    int nice;
	    
	    ....
	};

---- ალგორითმები ----
>> C2: Suppose threads A, B, and C have nice values 0, 1, and 2.  Each
>> has a recent_cpu value of 0.  Fill in the table below showing the
>> scheduling decision and the priority and recent_cpu values for each
>> thread after each given number of timer ticks:

timer  recent_cpu    priority   thread
ticks   A   B   C   A   B   C   to run
-----  --  --  --  --  --  --   ------
 0					
 4
 8
12
16
20
24
28
32
36

>> C3: Did any ambiguities in the scheduler specification make values
>> in the table uncertain?  If so, what rule did you use to resolve
>> them?  Does this match the behavior of your scheduler?

>> C4: How is the way you divided the cost of scheduling between code
>> inside and outside interrupt context likely to affect performance?

საშუალო დატვირთვა, ბოლოს გამოყენებული პროცესორის დრო ითვლება მოცემული ფორმულით.
timer_interrup ზრდის thread_ticks.

---- სინქრონიზაცია ----
საშუალო დატვირთვა იცვლება მხოლოდ მაშინ როცა ინტერაფთები გათიშულია.

---- რაციონალურობა ----
>> C5: Briefly critique your design, pointing out advantages and
>> disadvantages in your design choices.  If you were to have extra
>> time to work on this part of the project, how might you choose to
>> refine or improve your design?

>> C6: The assignment explains arithmetic for fixed-point math in
>> detail, but it leaves it open to you to implement it.  Why did you
>> decide to implement it the way you did?  If you created an
>> abstraction layer for fixed-point math, that is, an abstract data
>> type and/or a set of functions or macros to manipulate fixed-point
>> numbers, why did you do so?  If not, why not?

Trivial/sim

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?
   
	ამ დავალების სირთულე იყო საშუალოზე მეტი, წაიღო საკმაოდ დრო.

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?
	კი, ეს დავალება დაგვეხმარა ოპერაციული სისტემების სხვადასხვა ასპექტების უკეთესად გააზრებაში.

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?
	არა, რჩევები იყო საკმარისი.

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?
	არა


