Sample Design Document
+-----------------+
|
	CS 140
|
| PROJECT 2       |
| DESIGN DOCUMENT |
+-----------------+
---- GROUP ----
Luka Matcharadze <lmach14@freeuni.edu.ge>
Givi Beridze <gberi14@freeuni.edu.ge>
Giorgi Guliashvili<gguli13@freeuni.edu.ge>
Tornike Zhizhiashvili<tzhiz14@freeuni.edu.ge>
---- PRELIMINARIES ----
>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation,
>> course text, and lecture notes.
None.


TIMER BUSY WAIT IMPROVEMENT
===================

---- DATA STRUCTURES ----

/* ordered list of struct sleeping_thread */
static struct list sleeping_threads_list;

/* thread with additional wake_up information and list_elem for list, MAGIC for detecting overflows*/
struct sleeping_thread{
    struct list_elem elem;
    struct thread *thread;
    int64_t wake_up_time;
    int MAGIC;
};

---- ALGORITHMS ----
timer_init is called before anything else, it constructs the sleeping_threads_list.
timer_sleep inserts constructs sleeping_thread and inserts in sleeping_threads_list(ordered).
wake_up_threads pops struct sleeping_threads from the list if wake_up_time < now.

---- SYNCHRONIZATION ----
timer_interrupt thread can not be blocked so we use intr_disable in order to disable interrupts and
atomicly read/write from/in the list.

---- RATIONALE ----
List is not the best way to keep sorted elements inside. Min Priority Queue would be better choice,
but it would take more time and probebly we would have more bugs.


PRIORITY SCHEDULING
===================

---- DATA STRUCTURES ----

/* ordered list of struct sleeping_thread */
#define PRI_SIZE (PRI_MAX - PRI_MIN + 1)
#define PRI_AD (-PRI_MIN)
/* 64 separate queue for every priority */
static struct list ready_list[PRI_SIZE];


---- ALGORITHMS ----
Before ready_list was 1 queue, for easy priority scheduling each priority has it's own queue.
In this implementation Round robing is very easy to achieve with pop_front/push_back way.

---- SYNCHRONIZATION ----
intr_disable is used to atomicly read/write in/from the 64 ready_list queues.

---- RATIONALE ----
Buckets for each priority is nice and fast way to keep the ready threads. It would be better but harder if every queue had it's own lock, or even better if queues were non blocking.


PRIORITY DONATION
===================

---- DATA STRUCTURES ----

struct thread
{
    ...

    struct lock *waiting_lock;
    int priority;                       /* MAX(old_priority, donations) */
    struct list_elem allelem;           /* List element for all threads list. */
    int old_priority; /* latest priority setted by set_priority */


    /* Shared between thread.c and synch.c. */
    struct list_elem elem;              /* List element. */

    /* locks currently acquired by the thread */
    struct list acquired_locks_list;
    
    ...
};

---- ALGORITHMS ----
Each thread stores lock pointer it is now waitig for.
Each lock stores holder.
Each lock stores threads now waiting for it.
Each thread stores acquired locks.

When thread starts waiting(donating phase) or stops waiting(de donating phase) it askes lock holder(and so on rerecursively) do update it's own priority.
When thread wants to update it's own priority either during donating or de donating phase,
it itearates through all the locks it acquired and iterates through all the waiting threads of this locks, and sets max priority.


---- SYNCHRONIZATION ----
No need for synchronization, threads are only changing data inside their struct.

---- RATIONALE ----
Sometimes chain(graph) might be very long. Graph is not generic, each node has only 1 outgoing node. With some advanced data structures it might be possible to implement faster then O(n) update operation.



ADVANCED PRIORITY SCHEDULER
===================

---- DATA STRUCTURES ----

static unsigned thread_ticks;   /* # of timer ticks since last yield. */
static fixedPoint load_average = 0;
struct thread
{
    ....

    /* locks currently acquired by the thread */
    struct list acquired_locks_list;
    fixedPoint recent_cpu;

    int nice;
    
    ....
};

---- ALGORITHMS ----
load_average, recent_cpu is computed with the given formulas in homework.
timer_interrup increases thread_ticks.

---- SYNCHRONIZATION ----
load_average is changed only when intr is disabled.

---- RATIONALE ----
Trivial/sim


