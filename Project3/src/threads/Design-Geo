დიზაინ დოკუმენტი
+-----------------+
|
	CS 140
|
| პროექტი 2       |
| დიზაინ დოკუმენტი |
+-----------------+
---- ჯგუფი ----
ლუკა მაჭარაძე <lmach14@freeuni.edu.ge>
გივი ბერიძე <gberi14@freeuni.edu.ge>
გიორგი გულიაშვილი<gguli13@freeuni.edu.ge>
თორნიკე ჟიჟიაშვილი<tzhiz14@freeuni.edu.ge>
---- წინასიტყვაობა ----
>> დაწერეთ თუ გამოიყენოთ გარე წყაროები გარდა პინტოსისა
არაფერი.


TIMER BUSY WAIT გაუმჯობესდა
===================

---- მონაცემთა სტრუქტურები ----

/* სორტირებული სია  sleeping_thread */
static struct list sleeping_threads_list;

/* სრედს დაემატა გაღვიძების დამატებითი ინფორმაცია and list_elem სიისთვის, MAGIC გადავსების გასაგებად*/
struct sleeping_thread{
    struct list_elem elem;
    struct thread *thread;
    int64_t wake_up_time;
    int MAGIC;
};

---- ალგორითმები ----
timer_init იძახება ყველაფრის დაწყებამდე, ის ქმნის მძინარე სრედების სიას.
timer_sleep აწყობს მძინარე სრდებს და სვამს მათ სიაში.
wake_up_threads მძინარე სრედებს ყრის სიიდან თუ  wake_up_time < now.

---- სინქრონიზაცია ----
timer_interrupt სრედი შეუძLებელია დაიბლოკოს ამიტომ ჩვენ ვიყენებთ ინტერაფთების გათიშვას რათა გავთიშოთ ინტერაფთები
ატომური წაკითხვა/ჩაწერა ლისტიდან და ლისტში

---- რაციონალურობა ----
სია საუკეთესო გზა არაა ელემენტების სორტირებულად შესანახად. Min Priority Queue იქნებოდა უკეთესი მაგრამ ის ალბათ წაიღებდა უფრო მეტ დროს და ექნებოდა უფრო მეტი ბაგები.


პრიორიტეტებით გაშვება
===================

---- მონაცემთა სტრუქტურები ----

/* მძინარე სრედების სორტირებული სია */
#define PRI_SIZE (PRI_MAX - PRI_MIN + 1)
#define PRI_AD (-PRI_MIN)
/* 64 განსხვავებული რიგი ყველა პრიორეტისთვის */
static struct list ready_list[PRI_SIZE];


---- ალგორითმები ----
სანამ ready_list იყო ერთი რიგი, სიმარტივისთვის ყველა სრედს ქონდა თავისი საკუთარი რიგი .
ამ იმპლემენტაციაშI  Round robing არის უფრო მატივი  pop_front/push_back გზით.

---- სინქრონიზაცია ----
intr_disable გამოყენებულია ატომურობის ჩაწერა/წაკითხვისთვის  64 ready_list queues სიაში და სიიდან.

---- რაციონალურობა ----
Buckets for each priority is nice and fast way to keep the ready threads. It would be better but harder if every queue had it's own lock, or even better if queues were non blocking.


პრიორიტეტული დონაცია
===================

---- მონაცემთა სტრუქტურები ----

struct thread
{
    ...

    struct lock *waiting_lock;
    int priority;                       /* MAX(old_priority, donations) */
    struct list_elem allelem;           /* List element for all threads list. */
    int old_priority; /* latest priority setted by set_priority */


    /* Shared between thread.c and synch.c. */
    struct list_elem elem;              /* List element. */

    /* locks currently acquired by the thread */
    struct list acquired_locks_list;
    
    ...
};

---- ალგორითმები ----
ყველა სრედი ინახავს lock-ის  მიმთითებელს რომელსაც ელოდება.
ყველა სრედი ინახავს ჰოლდერს.
ყველა ლოქი ინახავს სრედებს რომელიც მას ელოდება.
ყველა სრედი ინახავს ლოქებს რომლებიც დალოქა.

როცა სრედი იწყებს ლოდინს(დონაციის ფაზა) ან რჩება ლოდინს .
როცა სრედს უნდა მიიღOს მაქსიმალური პრიორიტეტი , ის გადაუყვება ყველა სრედს რომელიც მას ელოდება ან ის ელოდება, ირჩევს მაქსიმალურ პრიორიტეტს და ისეტავს თავისთვის.


---- სინქრონიზაცია ----
არ იყო სინქრონიზაციის საჭიროება რადგან ყველა სრედი ცვლის მხოლოდ შიდა სტრუქტურას.

---- რაციონალურობა ----
ხანდახან ჯაჭვი შეიძლება იყოს ძალიან გრძელი. გრაფი არ არის ზოგადი, ყველა წვეროს აქვს მხოლოდ ერთი გამავალი წვერო. განსხვავებული მონაცემთა სტრუქტურებით ეს შესაძლოა ყოფილიყო უფრო სწრაფი O(N).



გაუმჯობესებული პრიორიტეტული გაშვება
===================

----მონაცემთა სტრუქტურები ----

static unsigned thread_ticks;   /* # of timer ticks since last yield. */
static fixedPoint load_average = 0;
struct thread
{
    ....

    /* locks currently acquired by the thread */
    struct list acquired_locks_list;
    fixedPoint recent_cpu;

    int nice;
    
    ....
};

---- ალგორითმები ----
საშუალო დატვირთვა, ბოლოს გამოყენებული პროცესორის დრო ითვლება მოცემული ფორმულით.
timer_interrup ზრდის thread_ticks.

---- სინქრონიზაცია ----
საშუალო დატვირთვა იცვლება მხოლოდ მაშინ როცა ინტერაფთები გათიშულია.

---- რაციონალურობა ----
Trivial/sim


