        +---------------------------+
		    | CS 140                    |
		    | PROJECT 3: VIRTUAL MEMORY	|
		    |	DESIGN DOCUMENT           |
		    +---------------------------+

---- GROUP ----

ლუკა მაჭარაძე <lmach14@freeuni.edu.ge>
გივი ბერიძე <gberi14@freeuni.edu.ge>
გიორგი გულიაშვილი<gguli13@freeuni.edu.ge>
თორნიკე ჟიჟიაშვილი<tzhiz14@freeuni.edu.ge>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

			PAGE TABLE MANAGEMENT
			=====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct swap_map{
    struct lock lock;
    struct bitmap *map;
};
მაპი დაკავებული სლოტებისთვის(თითო ბიტი  თითო PAGE_SIZE ზე მიუთითებს).
ლოქი სვაპიდან წაკითხვა ჩაწერის დასალოქად და ბიტმეპის scan_and_flipისთვის.

struct frame{
    struct supp_pagedir_entry *user;
    bool prohibit_cache;
    struct list_elem link;
    int MAGIC;
};
ფიზიკურად არსებული ფეიჯის სტრუქტურა.
მიმთითებელი დამათებით ფეიჯდირზე, აკრძალულია თუარა სვაპში გადატანა, ფეიჯ ევიქშენის ლისტში ჩასაწერად ლინკი, და მეჯიქი რომელიც მხოლოდ არსებობისაა FRAME_MAGIC ის ტოლი.

struct frame_map{
    int num_of_frames; // ფრეიმების რაოდენობა
    struct frame *frames; //ფრეიმების ერეიზე მიმთითებელი
    struct lock lock; // ფრეიმების გამოყოფისას ჩამკეტი, (ისეთი როგორიც პალოქს აქვს)

    struct lock list_lock; // ფეიჯ ევიქშენის ლისტის ლოქი
    struct list ordered_list; // ფეიჯ ევიქშენის ლისტი სადაც ჰედი არის ფოინთერი
};


struct supp_pagedir2{
    struct supp_pagedir_entry *entries[1<<PTBITS];
};

struct supp_pagedir{
    struct supp_pagedir2 *entries[1<<PDBITS];
};
pagedir ისნაირი 2 ჩადგმული ჰეშმეპი ოღონდ სტრუქტურებად

struct supp_pagedir_entry{
    struct lock lock;  // კონკრეტულ ფეიჯს იცავს მასზე მუშაობისას არ გადავიდეს სვაპში
    enum palloc_flags flags; // ფლეგები
    uint32_t **pagedir; // მფლობელი სრედის ფეიჯდირის მიმთითებლის მიმთითებელი

    block_sector_t sector_t; // სვაპის სლოტის ადგილი სადაც წერია ან -1
    int fd; // ფაილის მისამართი სადაც წერია ან -1
    int s; // ფაილში დასაწყისი ან -1
    int e; // ფაილში ბოლო ან -1

    void *upage; // იუზერისთვის რა ფოინთერზე იწყება ეს ფეიჯი
    int MAGIC; // თუ არსებობს უდრის PAGING_MAGIC.
};

enum palloc_flags
  {
...
    PAL_THROUGH_FRAME = 16, // იმისათვის რომ დავრწმუნებულიყავი კერნელი საიდანმე პალოქით პირდაპირ არ იღებდა ფეიჯებს იუზერ სფეისიდან, პალოქი იქრაშება თუ იუზერსფეისში ოპერაციას ამ ფლეგის გარეშე თხოვენ, ამ ფლეგს ანიჭებს frame.c
    PAL_PROHIBIT_CACHE = 32,  // არ გადავიდეს სვაპში ან ფაილში(არ გაქრეს ფიზიკურად რამიდან)
    PAL_DONT_SYNC_ON_DISK = 64 // ფაილზე აქვს მიმთითებელი მაგრამ არ გადავწეროთ შეცვილილი ფაილს
};

---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for accessing the data
>> stored in the SPT about a given page.

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?

---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

		       PAGING TO AND FROM DISK
		       =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

			 MEMORY MAPPED FILES
			 ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

I will never ever blame Windows programmers for BLUE SCREEN PROBLEM anymore.

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?
არსებულ ფუნქციონალზე (pte vaddr pagedir) ვინმე რო ყვებოდეს უფრო ჩქარა აითვისებენ.

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

Naah.
>> Any other comments?
